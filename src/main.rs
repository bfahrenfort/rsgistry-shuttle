mod auth;
mod db;
mod state;

use aide::{
    axum::{
        routing::{get, get_with, post},
        ApiRouter, IntoApiResponse,
    },
    openapi::{Info, OpenApi},
};
use axum::{Extension, Json};
use cute::c;
use scaffold::Entry;
use shuttle_runtime::CustomError;
use shuttle_secrets::{SecretStore, Secrets};
use sqlx::PgPool;

use state::MyState;

async fn hello_world() -> &'static str {
    "`rsgistry` API\n\
        \tDocumentation at /api.json"
}

async fn serve_api(Extension(api): Extension<OpenApi>) -> impl IntoApiResponse {
    Json(api)
}

#[shuttle_runtime::main]
async fn main(
    #[Secrets] secrets: SecretStore,
    #[shuttle_shared_db::Postgres(
        local_uri = "postgres://postgres:{secrets.PASSWORD}@localhost:19087/postgres"
    )]
    pool: PgPool,
) -> shuttle_axum::ShuttleAxum {
    sqlx::migrate!()
        .run(&pool)
        .await
        .map_err(CustomError::new)?;

    // TODO parse Cargo.toml to get metadata
    let mut api = OpenApi {
        info: Info {
            title: "rsgistry".to_string(),
            description: Some("API generated by rsgistry".to_string()),
            ..Info::default()
        },
        ..OpenApi::default()
    };

    let state = MyState { pool, secrets };
    let keys = Entry::get_keys();
    // TODO document routes
    let router = ApiRouter::new()
        .route("/api.json", get(serve_api))
        .api_route(
            "/",
            get_with(hello_world, |o| {
                o.id("index")
                    .description("Returns a hello message")
                    .response_with::<200, String, _>(|res| {
                        res.description("A hello message")
                            .example("`rsgistry` API\n\tDocumentation at /api.json")
                    })
            }),
        )
        .api_route("/api/v1/update", get(db::update::auth_push))
        .api_route("/api/v1/queue/add", post(db::update::enqueue))
        .api_route("/api/v1/queue/peek", get(db::fetch::queue_peek))
        .api_route("/api/v1/queue/fetch", get(db::fetch::queue_fetch))
        .api_route(
            &format!(
                "/api/v1/fetch/{}",
                // List comps look better than maps.
                c![format!(":{}", keys[x]), for x in 0..keys.len()].join("/")
            ),
            get(db::fetch::retrieve),
        )
        .api_route("/login", post(auth::login));

    #[cfg(debug_assertions)]
    {
        let router = router.api_route("/api/v1/debug/update", post(db::update::push));
        Ok(router
            .with_state(state)
            .finish_api(&mut api)
            .layer(Extension(api))
            .into())
    }

    #[cfg(not(debug_assertions))]
    {
        Ok(router
            .with_state(state)
            .finish_api(&mut api)
            .layer(Extension(api))
            .into())
    }
}
